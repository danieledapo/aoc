use std::collections::HashSet;

type Input = Vec<((i64, i64), (i64, i64))>;

fn dist(a: (i64, i64), b: (i64, i64)) -> i64 {
    i64::abs(a.0 - b.0) + i64::abs(a.1 - b.1)
}

pub fn part1(input: &Input, y: i64) -> usize {
    let minx = input.iter().map(|((x, _), _)| *x).min().unwrap();
    let maxx = input.iter().map(|((x, _), _)| *x).max().unwrap();
    let maxd = input.iter().map(|(p, b)| dist(*p, *b)).max().unwrap();

    let mut c = 0;
    for x in (minx - maxd)..=(maxx + maxd) {
        let occulted = input.iter().any(|(s, b)| dist(*s, (x, y)) <= dist(*s, *b));
        if occulted {
            c += 1;
            continue;
        }
    }

    let beacons = input
        .iter()
        .map(|(_, b)| b)
        .filter(|(_, by)| *by == y)
        .collect::<HashSet<_>>();

    c - beacons.len()
}

pub fn part2(input: &Input) -> i64 {
    for &((x0, y0), b0) in input {
        let d0 = dist((x0, y0), b0);

        for &((x1, y1), b1) in input {
            let d1 = dist((x1, y1), b1);

            let x = (x1 + y1 + d1 + x0 - y0 - d0) / 2;
            let y = (x1 + y1 + d1 - x0 + y0 + d0) / 2 + 1;

            if (0..4_000_000).contains(&x)
                && (0..4_000_000).contains(&y)
                && input.iter().all(|&(s, b)| dist(s, (x, y)) > dist(s, b))
            {
                return x * 4_000_000 + y;
            }
        }
    }

    unreachable!()
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_data() -> Input {
        vec![
            ((3999724, 2000469), (4281123, 2282046)),
            ((3995530, 8733), (3321979, -692911)),
            ((3016889, 2550239), (2408038, 2645605)),
            ((3443945, 3604888), (3610223, 3768674)),
            ((168575, 491461), (1053731, -142061)),
            ((2820722, 3865596), (3191440, 3801895)),
            ((2329102, 2456329), (2408038, 2645605)),
            ((3889469, 3781572), (3610223, 3768674)),
            ((3256726, 3882107), (3191440, 3801895)),
            ((3729564, 3214899), (3610223, 3768674)),
            ((206718, 2732608), (-152842, 3117903)),
            ((2178192, 2132103), (2175035, 2000000)),
            ((1884402, 214904), (1053731, -142061)),
            ((3060435, 980430), (2175035, 2000000)),
            ((3998355, 3965954), (3610223, 3768674)),
            ((3704399, 3973731), (3610223, 3768674)),
            ((1421672, 3446889), (2408038, 2645605)),
            ((3415633, 3916020), (3191440, 3801895)),
            ((2408019, 2263990), (2408038, 2645605)),
            ((3735247, 2533767), (4281123, 2282046)),
            ((1756494, 1928662), (2175035, 2000000)),
            ((780161, 1907142), (2175035, 2000000)),
            ((3036853, 3294727), (3191440, 3801895)),
            ((53246, 3908582), (-152842, 3117903)),
            ((2110517, 2243287), (2175035, 2000000)),
            ((3149491, 3998374), (3191440, 3801895)),
        ]
    }

    #[test]
    pub fn test_part1() {
        assert_eq!(5176944, part1(&get_data(), 2000000));
    }

    #[test]
    pub fn test_part2() {
        assert_eq!(13350458933732, part2(&get_data()));
    }
}
